<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Partial Least Squares Discriminant Analysis (PLS-DA).</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for plsda {mixOmics}"><tr><td>plsda {mixOmics}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Partial Least Squares Discriminant Analysis (PLS-DA).</h2>

<h3>Description</h3>

<p>Function to perform standard Partial Least Squares regression
to classify samples.
</p>


<h3>Usage</h3>

<pre>
plsda(X,
Y,
ncomp = 2,
scale = TRUE,
mode = c("regression", "canonical", "invariant", "classic"),
tol = 1e-06,
max.iter = 100,
near.zero.var = FALSE,
logratio="none",  # one of "none", "CLR"
multilevel=NULL,
all.outputs = TRUE)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>X</code></td>
<td>
<p>numeric matrix of predictors. <code>NA</code>s are allowed.</p>
</td></tr>
<tr valign="top"><td><code>Y</code></td>
<td>
<p>a factor or a class vector for the discrete outcome.</p>
</td></tr>
<tr valign="top"><td><code>ncomp</code></td>
<td>
<p>the number of components to include in the model. Default to 2.</p>
</td></tr>
<tr valign="top"><td><code>scale</code></td>
<td>
<p>boleean. If scale = TRUE, each block is standardized
to zero means and unit variances (default: TRUE)</p>
</td></tr>
<tr valign="top"><td><code>mode</code></td>
<td>
<p>character string. What type of algorithm to use, (partially) matching
one of <code>"regression"</code>, <code>"canonical"</code>, <code>"invariant"</code> or <code>"classic"</code>.
See Details.</p>
</td></tr>
<tr valign="top"><td><code>tol</code></td>
<td>
<p>Convergence stopping value.</p>
</td></tr>
<tr valign="top"><td><code>max.iter</code></td>
<td>
<p>integer, the maximum number of iterations.</p>
</td></tr>
<tr valign="top"><td><code>near.zero.var</code></td>
<td>
<p>boolean, see the internal <code><a href="nearZeroVar.html">nearZeroVar</a></code> function (should be set to TRUE in particular for data with many zero values). Setting this argument to FALSE (when appropriate) will speed up the computations. Default value is FALSE</p>
</td></tr>
<tr valign="top"><td><code>logratio</code></td>
<td>
<p>one of ('none','CLR') specifies the log ratio transformation to deal with compositional values that may arise from specific normalisation in sequencing dadta. Default to 'none'</p>
</td></tr>
<tr valign="top"><td><code>multilevel</code></td>
<td>
<p>sample information for multilevel decomposition for repeated measurements. A numeric matrix or data frame indicating the repeated measures on each individual, i.e. the individuals ID. See examples in <code>?splsda</code>.</p>
</td></tr>
<tr valign="top"><td><code>all.outputs</code></td>
<td>
<p>boolean. Computation can be faster when some specific (and non-essential) outputs are not calculated. Default = <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plsda</code> function fit PLS models with <i>1,...,</i><code>ncomp</code> components
to the factor or class vector <code>Y</code>. The appropriate indicator
matrix is created.
</p>
<p>logratio transform and multilevel analysis are performed sequentially as internal pre-processing step, through <code><a href="logratio.transfo.html">logratio.transfo</a></code> and <code><a href="withinVariation.html">withinVariation</a></code> respectively.
</p>
<p>Logratio can only be applied if the data do not contain any 0 value (for count data, we thus advise the normalise raw data with a 1 offset).
</p>
<p>More details about the PLS modes in <code>?pls</code>.
</p>


<h3>Value</h3>

<p><code>plsda</code> returns an object of class <code>"plsda"</code>, a list
that contains the following components:
</p>
<table summary="R valueblock">
<tr valign="top"><td><code>X</code></td>
<td>
<p>the centered and standardized original predictor matrix.</p>
</td></tr>
<tr valign="top"><td><code>Y</code></td>
<td>
<p>the centered and standardized indicator response vector or matrix.</p>
</td></tr>
<tr valign="top"><td><code>ind.mat</code></td>
<td>
<p>the indicator matrix.</p>
</td></tr>
<tr valign="top"><td><code>ncomp</code></td>
<td>
<p>the number of components included in the model.</p>
</td></tr>
<tr valign="top"><td><code>variates</code></td>
<td>
<p>list containing the <code>X</code> and <code>Y</code> variates.</p>
</td></tr>
<tr valign="top"><td><code>loadings</code></td>
<td>
<p>list containing the estimated loadings for the variates.</p>
</td></tr>
<tr valign="top"><td><code>names</code></td>
<td>
<p>list containing the names to be used for individuals and variables.</p>
</td></tr>
<tr valign="top"><td><code>nzv</code></td>
<td>
<p>list containing the zero- or near-zero predictors information.</p>
</td></tr>
<tr valign="top"><td><code>tol</code></td>
<td>
<p>the tolerance used in the iterative algorithm, used for subsequent S3 methods</p>
</td></tr>
<tr valign="top"><td><code>max.iter</code></td>
<td>
<p>the maximum number of iterations, used for subsequent S3 methods</p>
</td></tr>
<tr valign="top"><td><code>iter</code></td>
<td>
<p>Number of iterations of the algorthm for each component</p>
</td></tr>
<tr valign="top"><td><code>explained_variance</code></td>
<td>
<p>amount of variance explained per component (note that contrary to PCA, this amount may not decrease as the aim of the method is not to maximise the variance, but the covariance between X and the dummy matrix Y).</p>
</td></tr>
<tr valign="top"><td><code>mat.c</code></td>
<td>
<p>matrix of coefficients from the regression of X / residual matrices X on the X-variates, to be used internally by <code>predict</code>.</p>
</td></tr>
<tr valign="top"><td><code>defl.matrix</code></td>
<td>
<p>residual matrices X for each dimension.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ignacio González, Kim-Anh Lê Cao.</p>


<h3>References</h3>

<p>On PLSDA:
Barker M and Rayens W (2003). Partial least squares for discrimination. <em>Journal of Chemometrics</em> <b>17</b>(3), 166-173.
Perez-Enciso, M. and Tenenhaus, M. (2003). Prediction of clinical outcome with microarray data:
a partial least squares discriminant analysis (PLS-DA) approach. <em>Human Genetics</em>
<b>112</b>, 581-592.
Nguyen, D. V. and Rocke, D. M. (2002). Tumor classification by partial
least squares using microarray gene expression data. <em>Bioinformatics</em>
<b>18</b>, 39-50.
On log ratio transformation:
Filzmoser, P., Hron, K., Reimann, C.: Principal component analysis for compositional data with outliers. Environmetrics 20(6), 621-632 (2009)
Lê Cao K.-A., Costello ME,  Lakis VA, Bartolo, F,Chua XY, Brazeilles R, Rondeau P. MixMC: Multivariate insights into Microbial Communities. PLoS ONE, 11(8): e0160169 (2016).
On multilevel decomposition:
Westerhuis, J.A., van Velzen, E.J., Hoefsloot, H.C., Smilde, A.K.: Multivariate paired data analysis: multilevel plsda versus oplsda. Metabolomics 6(1), 119-128 (2010)
Liquet, B., Lê Cao K.-A., Hocini, H., Thiebaut, R.: A novel approach for biomarker selection and the integration of repeated measures experiments from two assays. BMC bioinformatics 13(1), 325 (2012)
</p>


<h3>See Also</h3>

<p><code><a href="splsda.html">splsda</a></code>, <code><a href="summary.html">summary</a></code>,
<code><a href="plotIndiv.html">plotIndiv</a></code>, <code><a href="plotVar.html">plotVar</a></code>,
<code><a href="predict.html">predict</a></code>, <code><a href="perf.html">perf</a></code>, <code><a href="mint.block.plsda.html">mint.block.plsda</a></code>, <code><a href="block.plsda.html">block.plsda</a></code> and http://mixOmics.org for more details.</p>


<h3>Examples</h3>

<pre>
## First example
data(breast.tumors)
X &lt;- breast.tumors$gene.exp
Y &lt;- breast.tumors$sample$treatment

plsda.breast &lt;- plsda(X, Y, ncomp = 2)
plotIndiv(plsda.breast, ind.names = TRUE, ellipse = TRUE, legend = TRUE)


## Not run: 
## Second example
data(liver.toxicity)
X &lt;- liver.toxicity$gene
Y &lt;- liver.toxicity$treatment[, 4]

plsda.liver &lt;- plsda(X, Y, ncomp = 2)
plotIndiv(plsda.liver, ind.names = Y, ellipse = TRUE, legend =TRUE)


## End(Not run)
</pre>

<hr /><div style="text-align: center;">[Package <em>mixOmics</em> version 6.10.8 <a href="00Index.html">Index</a>]</div>
</body></html>

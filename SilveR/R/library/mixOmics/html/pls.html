<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Partial Least Squares (PLS) Regression</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for pls {mixOmics}"><tr><td>pls {mixOmics}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Partial Least Squares (PLS) Regression</h2>

<h3>Description</h3>

<p>Function to perform Partial Least Squares (PLS) regression.
</p>


<h3>Usage</h3>

<pre>
pls(X,
Y,
ncomp = 2,
scale = TRUE,
mode = c("regression", "canonical", "invariant", "classic"),
tol = 1e-06,
max.iter = 100,
near.zero.var = FALSE,
logratio="none",
multilevel=NULL,
all.outputs = TRUE)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>X</code></td>
<td>
<p>numeric matrix of predictors. <code>NA</code>s are allowed.</p>
</td></tr>
<tr valign="top"><td><code>Y</code></td>
<td>
<p>numeric vector or matrix of responses (for multi-response models).
<code>NA</code>s are allowed.</p>
</td></tr>
<tr valign="top"><td><code>ncomp</code></td>
<td>
<p>the number of components to include in the model. Default to 2.</p>
</td></tr>
<tr valign="top"><td><code>scale</code></td>
<td>
<p>boleean. If scale = TRUE, each block is standardized
to zero means and unit variances (default: TRUE)</p>
</td></tr>
<tr valign="top"><td><code>mode</code></td>
<td>
<p>character string. What type of algorithm to use, (partially) matching
one of <code>"regression"</code>, <code>"canonical"</code>, <code>"invariant"</code> or <code>"classic"</code>.
See Details.</p>
</td></tr>
<tr valign="top"><td><code>tol</code></td>
<td>
<p>Convergence stopping value.</p>
</td></tr>
<tr valign="top"><td><code>max.iter</code></td>
<td>
<p>integer, the maximum number of iterations.</p>
</td></tr>
<tr valign="top"><td><code>near.zero.var</code></td>
<td>
<p>boolean, see the internal <code><a href="nearZeroVar.html">nearZeroVar</a></code> function (should be set to TRUE in particular for data with many zero values). Setting this argument to FALSE (when appropriate) will speed up the computations. Default value is FALSE</p>
</td></tr>
<tr valign="top"><td><code>logratio</code></td>
<td>
<p>one of ('none','CLR'). Default to 'none'</p>
</td></tr>
<tr valign="top"><td><code>multilevel</code></td>
<td>
<p>Design matrix for repeated measurement analysis, where multlevel decomposition is required. For a one factor decomposition, the repeated measures on each individual, i.e. the individuals ID is input as the first column. For a 2 level factor decomposition then 2nd AND 3rd columns indicate those factors. See examples in <code>?spls</code>).</p>
</td></tr>
<tr valign="top"><td><code>all.outputs</code></td>
<td>
<p>boolean. Computation can be faster when some specific (and non-essential) outputs are not calculated. Default = <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pls</code> function fit PLS models with <i>1, &hellip; ,</i><code>ncomp</code> components.
Multi-response models are fully supported. The <code>X</code> and <code>Y</code> datasets
can contain missing values.
</p>
<p>The type of algorithm to use is specified with the <code>mode</code> argument. Four PLS
algorithms are available: PLS regression <code>("regression")</code>, PLS canonical analysis
<code>("canonical")</code>, redundancy analysis <code>("invariant")</code> and the classical PLS
algorithm <code>("classic")</code> (see References). Different modes relate on how the Y matrix is deflated across the iterations of the algorithms - i.e. the different components.
</p>
<p>- Regression mode: the Y matrix is deflated with respect to the information extracted/modelled from the local regression on X. Here the goal is to predict Y from X (Y and X play an asymmetric role). Consequently the latent variables computed to predict Y from X are different from those computed to predict X from Y.
</p>
<p>- Canonical mode: the Y matrix is deflated to the information extracted/modelled from the local regression on Y. Here X and Y play a symmetric role and the goal is similar to a Canonical Correlation type of analysis.
</p>
<p>- Invariant mode: the Y matrix is not deflated
</p>
<p>- Classic mode: is similar to a regression mode. It gives identical results for the variates and loadings associated to the X data set, but differences for the loadings vectors associated to the Y data set (different normalisations are used). Classic mode is the PLS2 model as defined by Tenenhaus (1998), Chap 9.
</p>
<p>Note that in all cases the results are the same on the first component as deflation only starts after component 1.
</p>
<p>The estimation of the missing values can be performed
by the reconstitution of the data matrix using the <code>nipals</code> function. Otherwise, missing
values are handled by casewise deletion in the <code>pls</code> function without having to
delete the rows with missing data.
</p>
<p>logratio transform and multilevel analysis are performed sequentially as internal pre-processing step, through <code><a href="logratio.transfo.html">logratio.transfo</a></code> and <code><a href="withinVariation.html">withinVariation</a></code> respectively.
</p>


<h3>Value</h3>

<p><code>pls</code> returns an object of class <code>"pls"</code>, a list
that contains the following components:
</p>
<table summary="R valueblock">
<tr valign="top"><td><code>X</code></td>
<td>
<p>the centered and standardized original predictor matrix.</p>
</td></tr>
<tr valign="top"><td><code>Y</code></td>
<td>
<p>the centered and standardized original response vector or matrix.</p>
</td></tr>
<tr valign="top"><td><code>ncomp</code></td>
<td>
<p>the number of components included in the model.</p>
</td></tr>
<tr valign="top"><td><code>mode</code></td>
<td>
<p>the algorithm used to fit the model.</p>
</td></tr>
<tr valign="top"><td><code>variates</code></td>
<td>
<p>list containing the variates.</p>
</td></tr>
<tr valign="top"><td><code>loadings</code></td>
<td>
<p>list containing the estimated loadings for the <i>X</i> and
<i>Y</i> variates.</p>
</td></tr>
<tr valign="top"><td><code>names</code></td>
<td>
<p>list containing the names to be used for individuals and variables.</p>
</td></tr>
<tr valign="top"><td><code>tol</code></td>
<td>
<p>the tolerance used in the iterative algorithm, used for subsequent S3 methods</p>
</td></tr>
<tr valign="top"><td><code>iter</code></td>
<td>
<p>Number of iterations of the algorthm for each component</p>
</td></tr>
<tr valign="top"><td><code>max.iter</code></td>
<td>
<p>the maximum number of iterations, used for subsequent S3 methods</p>
</td></tr>
<tr valign="top"><td><code>nzv</code></td>
<td>
<p>list containing the zero- or near-zero predictors information.</p>
</td></tr>
<tr valign="top"><td><code>scale</code></td>
<td>
<p>whether scaling was applied per predictor.</p>
</td></tr>
<tr valign="top"><td><code>logratio</code></td>
<td>
<p>whether log ratio transformation for relative proportion data was applied, and if so, which type of transformation.</p>
</td></tr>
<tr valign="top"><td><code>explained_variance</code></td>
<td>
<p>amount of variance explained per component (note that contrary to PCA, this amount may not decrease as the aim of the method is not to maximise the variance, but the covariance between data sets).</p>
</td></tr>
<tr valign="top"><td><code>input.X</code></td>
<td>
<p>numeric matrix of predictors in X that was input, before any saling / logratio / multilevel transformation.</p>
</td></tr>
<tr valign="top"><td><code>mat.c</code></td>
<td>
<p>matrix of coefficients from the regression of X / residual matrices X on the X-variates, to be used internally by <code>predict</code>.</p>
</td></tr>
<tr valign="top"><td><code>defl.matrix</code></td>
<td>
<p>residual matrices X for each dimension.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sébastien Déjean and Ignacio González and Kim-Anh Lê Cao.</p>


<h3>References</h3>

<p>Tenenhaus, M. (1998). <em>La regression PLS: theorie et pratique</em>. Paris: Editions Technic.
</p>
<p>Wold H. (1966). Estimation of principal components and related models by iterative least squares. In: Krishnaiah, P. R. (editors), <em>Multivariate Analysis</em>. Academic Press, N.Y., 391-420.
</p>
<p>Abdi H (2010). Partial least squares regression and projection on latent structure regression (PLS Regression). <em>Wiley Interdisciplinary Reviews: Computational Statistics</em>, 2(1), 97-106.
</p>


<h3>See Also</h3>

<p><code><a href="spls.html">spls</a></code>, <code><a href="summary.html">summary</a></code>,
<code><a href="plotIndiv.html">plotIndiv</a></code>, <code><a href="plotVar.html">plotVar</a></code>, <code><a href="predict.html">predict</a></code>, <code><a href="perf.html">perf</a></code> and http://www.mixOmics.org for more details.</p>


<h3>Examples</h3>

<pre>
data(linnerud)
X &lt;- linnerud$exercise
Y &lt;- linnerud$physiological
linn.pls &lt;- pls(X, Y, mode = "classic")

## Not run: 
data(liver.toxicity)
X &lt;- liver.toxicity$gene
Y &lt;- liver.toxicity$clinic
toxicity.pls &lt;- pls(X, Y, ncomp = 3)

## End(Not run)
</pre>

<hr /><div style="text-align: center;">[Package <em>mixOmics</em> version 6.10.8 <a href="00Index.html">Index</a>]</div>
</body></html>
